Watchdog 有兩種「檔案監控引擎」（backend，後端實作）：
原生後端 Native Observer

直接用作業系統的即時通知機制
Windows: ReadDirectoryChangesW
Linux: inotify
macOS: FSEvents
優點：即時、效能好、事件類型更準（可分得出 rename/move）
缺點：在某些環境不穩定（例如監看整個磁碟根目錄、UNC 網路磁碟、虛擬/同步磁碟），可能出現驚異崩潰或遺漏事件
輪詢後端 PollingObserver

不靠 OS 通知，而是每隔 N 秒掃描目錄，比對前後快照判斷變更
優點：最穩、通用（本機/網路/虛擬檔案系統都能用），不會踩到原生 API 的坑
缺點：不是「即時」，有輪詢延遲；會多一些 I/O；某些事件會表現成「刪除+新增」而非真正的 rename
這裡的「後端」只是指「監控引擎的內部實作方式」，並不是前端/後端那種 Web 架構的「前端 UI」。所以你問的「前端是什麼」在這個脈絡其實沒有對應物；只有「原生後端」和「輪詢後端」兩種選擇。

什麼時候用哪一個

優先用原生後端（效能好）：本機 NTFS、固定的子資料夾範圍、事件可靠
建議切換到輪詢後端（更穩定）：
監看磁碟根目錄（C:\、D:\）
監看 UNC 網路分享（\server\share）
OneDrive/Dropbox/VM 共享資料夾等虛擬或同步磁碟
遇到像你那種 0x80000003 異常（原生層崩潰）
取捨

原生：低 CPU/IO、即時，但在某些檔案系統/根目錄情境會不穩
輪詢：穩定、通用，但有 0.5–2 秒延遲（你可調整），多做一些掃描
在你的程式裡怎麼切

全程強制輪詢（最穩）：啟動前設 WATCHDOG_FORCE_POLLING=1，或用我給你的 main.py 版本自動偵測「根目錄/UNC」就切到 PollingObserver
調整輪詢頻率：settings.POLLING_INTERVAL_SEC（例如 1.0 秒）。越小越即時，但 I/O 也會多一點
小貼士

輪詢模式下 rename 常會看起來像「刪除 + 新增」兩個事件，這是正常現象
監看大範圍時，記得排除系統資料夾、回收桶，以及你的 cache/history 輸出資料夾，減少噪音與自觸發
總結

PollingObserver 不是「前端」，而是「用輪詢方式運作的監控後端」；另一種是「原生後端」
你的 0x80000003 現象很像原生後端在根目錄/新檔建立時踩坑；改用輪詢後端即可規避
